#pragma checksum "/Users/xlash/Code/Blake/Blake.Client/Pages/Snake.razor" "{ff1816ec-aa5e-4d10-87f7-6f4963833460}" "b1567dd57244595d4e14135866020fdb91602fea"
// <auto-generated/>
#pragma warning disable 1591
#pragma warning disable 0414
#pragma warning disable 0649
#pragma warning disable 0169

namespace Blake.Client.Pages
{
    #line hidden
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Threading.Tasks;
    using Microsoft.AspNetCore.Components;
#line 1 "/Users/xlash/Code/Blake/Blake.Client/_Imports.razor"
using System.Net.Http;

#line default
#line hidden
#line 2 "/Users/xlash/Code/Blake/Blake.Client/_Imports.razor"
using Microsoft.AspNetCore.Components.Forms;

#line default
#line hidden
#line 3 "/Users/xlash/Code/Blake/Blake.Client/_Imports.razor"
using Microsoft.AspNetCore.Components.Layouts;

#line default
#line hidden
#line 4 "/Users/xlash/Code/Blake/Blake.Client/_Imports.razor"
using Microsoft.AspNetCore.Components.Routing;

#line default
#line hidden
#line 5 "/Users/xlash/Code/Blake/Blake.Client/_Imports.razor"
using Microsoft.JSInterop;

#line default
#line hidden
#line 6 "/Users/xlash/Code/Blake/Blake.Client/_Imports.razor"
using Blake.Client;

#line default
#line hidden
#line 7 "/Users/xlash/Code/Blake/Blake.Client/_Imports.razor"
using Blake.Client.Shared;

#line default
#line hidden
#line 2 "/Users/xlash/Code/Blake/Blake.Client/Pages/Snake.razor"
using System.Threading;

#line default
#line hidden
#line 3 "/Users/xlash/Code/Blake/Blake.Client/Pages/Snake.razor"
using Blake.Shared;

#line default
#line hidden
    [Microsoft.AspNetCore.Components.Layouts.LayoutAttribute(typeof(MainLayout))]
    [Microsoft.AspNetCore.Components.RouteAttribute("/snake")]
    public class Snake : Microsoft.AspNetCore.Components.ComponentBase
    {
        #pragma warning disable 1998
        protected override void BuildRenderTree(Microsoft.AspNetCore.Components.RenderTree.RenderTreeBuilder builder)
        {
        }
        #pragma warning restore 1998
#line 57 "/Users/xlash/Code/Blake/Blake.Client/Pages/Snake.razor"
       
    private enum Tile {
        Empty = 0,
        Block,
        Player,
        Apple
    }

    private enum Direction {
        Up = 0,
        Down,
        Left,
        Right
    }

    private enum GameState {
        Stop = 0,
        Running,
        GameOver
    }

    const int MapSize = 20;
    const int GameLoopMs = 250;

    private string ObjectToString(object o) {
        return Convert.ToString(o).ToLowerInvariant();
    }

    private List<(int, int)> Blocks = new List<(int, int)>();
    private List<(int, int)> Player = new List<(int, int)>();
    private Tile[,] Screen = new Tile[MapSize, MapSize];
    private (int, int) Apple;
    private Random _random = new Random();
    
    private GameState _currentState = GameState.Stop;
    private int Score = 0;
    private Timer _gameLoop;
    private int _gameLoopMs = GameLoopMs;

    private Direction _currentDirection = Direction.Right;
    private Direction CurrentDirection {
        get { return _currentDirection; }
        set {
            if ((_currentDirection == Direction.Up && value == Direction.Down) ||
                (_currentDirection == Direction.Down && value == Direction.Up) ||
                (_currentDirection == Direction.Right && value == Direction.Left) ||
                (_currentDirection == Direction.Left && value == Direction.Right))
            {
                return;
            }

            _currentDirection = value;
        }
    }

    Dictionary<string[], Direction> InputMapping = new Dictionary<string[], Direction> {
      { new string[] { "ArrowUp", "KeyW" }, Direction.Up },
      { new string[] { "ArrowDown", "KeyS" }, Direction.Down },
      { new string[] { "ArrowLeft", "KeyA" }, Direction.Left },
      { new string[] { "ArrowRight", "KeyD" }, Direction.Right }
    };

    protected override void OnInit()
    {
        Logger.Info("OnInit");
        _gameLoop = new Timer(GameLoop, null, 0, 0);
        Init();
    }

    protected override async Task OnInitAsync()
    {
        Logger.Info("OnInitAsync");
        await JsRuntime.InvokeAsync<object>("snakeFunctions.startInputHandler");

        var self = DotNetObjectRef.Create(this);
        // https://github.com/aspnet/AspNetCore/issues/11159
        await JsRuntime.InvokeAsync<object>("snakeFunctions.startInputHandler", self);
    }

    protected override async Task OnAfterRenderAsync()
    {
        Logger.Info("OnAfterRenderAsync");
        // TEMPORARY: Currently we need this guard to avoid making the interop
        // call during prerendering. Soon this will be unnecessary because we
        // will change OnAfterRenderAsync so that it won't run during the
        // prerendering phase.
        if (!ComponentContext.IsConnected)
        {
            return;
        }
    }

    public void StartGame() {
        Init();
    }

    private void Init() {
        Score = 0;
        _gameLoopMs = GameLoopMs;
        _currentState = GameState.Running;
        _currentDirection = Direction.Right;

        Blocks.Clear();
        for (int y = 0; y < MapSize; ++y) {
            for (int x = 0; x < MapSize; ++x) {
                if (x == 0 || y == 0 || x == MapSize - 1 || y == MapSize - 1) {
                    Blocks.Add((x, y));
                }
            }
        }

        Player.Clear();
        for (int i = 0; i < 5; ++i) {
            Player.Add((4 + i, 4));
        }

        UpdateApple();

        _gameLoop.Change(_gameLoopMs, _gameLoopMs);
    }

    private void StartGameLoop() {
    }

    [JSInvokable]
    public string HandleInput(string jsKeyCode) {
        Console.WriteLine($"Input: {jsKeyCode}");
        var input = InputMapping.FirstOrDefault(kvp => kvp.Key.Contains(jsKeyCode));
        if (!input.Equals(default)) {
            CurrentDirection = input.Value;
        }

        return "Thanks from C#!";
    }

    private void GameLoop(object _) {
        Logger.Info("Game Loop!");
        
        if (_currentState != GameState.Running) {
            return;
        }

        UpdateScreen();
        this.StateHasChanged();
    }

    private void UpdateApple() {
        int x = 0;
        int y = 0;
        do
        {
            x = _random.Next(0, MapSize);
            y = _random.Next(0, MapSize);
        } while (Blocks.Contains((x, y)) || Player.Contains((x, y)));

        Apple = (x, y);
    }

    private void UpdateScreen() {
        // Move Player
        var (pX, pY) = Player.Last();
        switch (CurrentDirection) {
            case Direction.Up:
                pY = pY - 1;
                break;
            case Direction.Down:
                pY = pY + 1;
                break;
            case Direction.Left:
                pX = pX - 1;
                break;
            case Direction.Right:
                pX = pX + 1;
                break;
        }

        // Game Logic
        if (Blocks.Contains((pX, pY))) {
            _currentState = GameState.GameOver;
        }

        if (Player.Contains((pX, pY))) {
            _currentState = GameState.GameOver;
        }

        //if (pX < 0) pX = MapSize - 1;
        //if (pX >= MapSize) pX = 0;
        //if (pY < 0) pY = MapSize - 1;
        //if (pY >= MapSize) pY = 0;
        Player.RemoveAt(0);
        Player.Add((pX, pY));

        if (Player.Contains(Apple)) {
            Score++;
            if (Score < 20) {
                _gameLoopMs = _gameLoopMs - 10;
                _gameLoop.Change(_gameLoopMs, _gameLoopMs);
            }
            Player.Insert(0, (pX, pY));
            UpdateApple();
        }

        // Update Screen
        for (int y = 0; y < MapSize; ++y) {
            for (int x = 0; x < MapSize; ++x) {
                if (Player.Contains((x, y))) {
                    Screen[x, y] = Tile.Player;
                }
                else if (Blocks.Contains((x, y))) {
                    Screen[x, y] = Tile.Block;
                }
                else if (Apple == (x, y)) {
                    Screen[x, y] = Tile.Apple;
                }
                else {
                    Screen[x, y] = Tile.Empty;
                }
            }
        }
    }

#line default
#line hidden
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private IJSRuntime JsRuntime { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private IComponentContext ComponentContext { get; set; }
        [global::Microsoft.AspNetCore.Components.InjectAttribute] private Logger Logger { get; set; }
    }
}
#pragma warning restore 1591
